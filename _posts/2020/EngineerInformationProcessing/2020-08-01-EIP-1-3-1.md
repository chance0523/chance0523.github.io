---
title: "2020 정처기 필기 - 1.3 애플리케이션 설계(1)"
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories: EngineerInformationProcessing
meta_keywords: 정처기, 정처기필기, 정보처리기사
date: 2020-08-01 00:43:00 -0400
last_modified_at: 2020-08-01T00:43:00+08:00
---

# 소프트웨어 아키텍처

### 소프트웨어 아키텍처의 설계

- 소프트웨어의 골격이 되는 기본 구조
- 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
- 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정

### 모듈화

- 소프트웨어의 성능을 향상하거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
- 모듈의 크기와 개수는 반비례관계, 개수와 통합 비용은 비례 관계

### 추상화

- 문제의 전체를 설계 후 세분화하여 구체화하는 과정
- 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어 여러가지 요인들을 테스트할 수 있음
- 추상화 유형
  - 과정 추상화 : 전반적인 흐름만 파악
  - 데이터 추상화 : 데이터의 세부 사항은 정의하지 않고 구조를 대표할 수 있는 표현으로 대체
  - 제어 추상화 : 이벤트의 발생의 세부사항은 정의하지 않고 구조를 대표할 수 있는 표현으로 대체

### 단계적 분해

- 문제를 상위 중요 개념으로부터 하위의 개념으로 구체화하는 분할 기법
- 추상화의 반복으로 세분화

### 정보 은닉

- 한 모듈 내부에 포함된 정보들을 감추어 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
- 다른 모듈과 커뮤니케이션을 할 때는 필요한 정보만 인터페이스를 통해 주고 받음
- 모듈을 독립적으로 수행하기 때문에 다른 모듈에 영향을 주지 않아 수정, 시험, 유지보수가 용이

### 소프트웨어 아키텍처의 품질 속성

- 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지하고 보장할 수 있게 설계되었는지를 확인하기 위해 품질 요소들을 구체화시켜 놓은 것
- <img src="https://blog.kakaocdn.net/dn/bgPcgi/btqDhu4fZlW/lalDfRU3B7CaksQKOIK3gk/img.png">

### 소프트웨어 아키텍처의 설계 과정

- <img src="https://blog.kakaocdn.net/dn/Tp1TU/btqDjHVV6TD/ipV4O8QLpKkaJKi39az4x0/img.png">

# 아키텍처 패턴

### 아키텍처 패턴의 개요

- 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- 시스템의 구조를 구성하기 위한 기본적인 틀을 제공
- 서브시스템과그 역할이 정의되어 있어 서브시스템 사이 관계와 규칙, 지침 등이 포함되어 있음
- 아키텍처 패턴의 장점

  - 개발 시간을 단축시킴
  - 고품질의 소프트웨어 생산 가능
  - 검증된 구조로 작업을 하여 안정적인 개발 가능
  - 시스템 구조를 이해하기 쉬워 개발에 참여하지 않아도 유지보수가 쉬움

### 레이어 패턴

- 시스템을 계층으로 구분하여 구성
- 각각의 서브 시스템이 계층 구조를 이룸
- 상위 계층은 하위 계층에 대한 서비스 제공자가 되고 하위 계층은 상위 계층의 클라이언트가 됨
- 마주 보는 두 계층 사이에만 상호작용이 이루어짐
- 특정 계층만을 교체해 시스템을 개선하는 것이 가능
- <img src="https://blog.kakaocdn.net/dn/biWar3/btqDeUJUGZJ/hdpkUJ2FoY3wFCY2JCEfUK/img.png">

### 클라이언트-서버 패턴

- 하나의 서버와 다수의 클라이언트로 구성
- 사용자는 클라이언트를 통해 서버에 요청하고 응답을 받아 사용자에게 제공
- 서버는 클라이언트의 요청에 대비해 항상 대기 상태 유지
- 요청을 위하여 동기화되는 경우를 제외하고는 서로 독립적임
- <img src="https://blog.kakaocdn.net/dn/o2hPQ/btqDhvoBGP2/7K5rICnRgvsNfTBENkPQh1/img.png">

### 파이프-필터 패텅

- 데이터 스트림(데이터가 송수신되거나 처리되는 흐름) 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송
- 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장이 용이
- 필터 컴포넌트를 재배치하여 다양한 파이프라인 구축 가능
- 데이터 변환, 버퍼링, 동기화 등에 사용
- <img src="https://blog.kakaocdn.net/dn/ICJ3J/btqDeUDcD5h/0aNQlejUxFYNp8IjZaphKk/img.png">

### 모델-뷰-컨트롤러 패턴

- 서브 시스템을 3개의 부분으로 구조화
- 모델 : 서브시스템의 핵심 기능과 데이터 보관
- 뷰 : 사용자에게 정보 표시
- 컨트롤러 : 사용자로부터 받은 입력 처리
- 각 부분은 별도로 분리되어 있어 서로 영향을 받지 않고 독립적인 개발 작업 수행
- 여러 개의 뷰를 만들 수 있어 한 개의 모델에 여러 개의 뷰를 필요로 하는 대화형 애프리케이션에 적합
- <img src="https://blog.kakaocdn.net/dn/l7Bl8/btqDgyTKj14/h8j17A94oG3xzOU7swdsk0/img.png">

# 객체지향(Object-Oriented)

### 객체지향의 개요

- 현실 세계의 개체를 기계의 부품처럼 하나의 객체(Object)로 만들어 소프트웨러를 개발할 때 객체를 조립하여 작성할 수 있는 기법
- 구조적 기법의 문제점을 해결하기 위해 사용
- 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있어 유지보수가 쉬움
- 복잡한 구조를 단계적이고 계층적이게 표현
- 멀티미디어 데이터 및 병렬 처리 지원
- 구성 요소 : 객체, 클래스, 캡슐화, 상속, 다형성

### 객체

- 데이터와 데이터를 처리하는 함수를 묶어 캡슐화한 하나의 소프트웨어 모듈
- 데이터 : 객체가 가지고 있는 정보
- 함수 : 객체가 수행하는 기능으로 데이터를 처리하는 알고리즘
- 객체의 특성
  - 객체는 독립적으로 식별 가능한 이름을 가지고 있음
  - 객체의 상태는 시간에 따라 변함
  - 객체 간의 상호 연관성에 의해 관계 형성
  - 객체가 반응 할 수 있는 메시지의 집합을 행위라고 하며 객체는 행위의 특징을 나타낼 수 있음
  - 객체는 일정한 기억 장소를 가지고 있음

### 클래스

- 공통된 속성과 연산을 갖는 객체의 집합으로 객체의 일반적인 타입을 의미
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
- 인스턴스 : 클래스에 속한 각각의 객체
- 인스턴스화 : 클래스로부터 새로운 객체를 생성하는 것
- 슈퍼 클래스 : 특정 클래스의 부모(상위) 클래스
- 서브 클래스 : 특정 클래스의 자식(하위) 클래스

### 상속

- 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
- 하위 클래스는 부모 클래스의 모든 속성과 연산을 다시 정의하지 않고 사용할 수 있음
- 하위 클래스는 상속받은 속성 외에 새로운 속성과 연산을 첨가하여 사용할 수 있음
- 객체와 클래스의 재사용을 높이는 중요한 개념
- 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 상속받는 것

### 다형성

- 메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 클래스가 가지고 있는 고유한 특성으로 응답할 수 있는 능력
- 객체지향의 오버로딩의 개념
- C++ 오버로딩과 오버라이딩

# 출처

- <https://1d1cblog.tistory.com/145>
